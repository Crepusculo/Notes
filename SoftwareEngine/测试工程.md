
# 系统/软件产品质量
(那个图)
功能性是基础 后面的维度可以看做是从不同的角度来观察
并不是所有维度都同样重要 对于不同的软件有不同的侧重点
+ ## 功能性
    + 功能完备性
    + 功能正确性
    + 功能适合性
+ ## 兼容性
+ ## 易用性(最主要的一个特性)
    + 可辨识: 用户要知道你是干嘛的
        + 调查问卷
    + 易学性: 容易上手
        + PPT上的内容
        + 找一堆特点智商的用户在一定条件下学习, 来通过学习结果估算
    + 易操作性: 学会以后 操作起来的难度
    + 用户差错防御性:
        + 用户什么事儿都干, 用户什么都不懂
        + 防止用户错误的操作
    + 用户界面舒适性:
        + 要 好 看
        + 用户什么都不懂 用户就会BB 要学会引导他们
    + 易访问性:
        + 让不同条件的人群都访问舒适
    + 依从
+ ## 可靠性
    + 可靠性本质是从硬件继承而来 软件本身是没有"磨损"的概念
    + 成熟性:
        + 用时间测 正常使用的时间
    + 可用性:
        + 用时间测 可使用的时间
    + 容错性:
        + 在硬件和软件有错误情况下 正常使用的时间
    + 易恢复性:
        + 中断/失效时 恢复 到期望状态的能力
    + 可靠性的依从性:
+ ## 信息安全性: 从功能性中独立
    + 保密性:
        + 确保授权访问
    + 完整性:
        + 防止未授权访问
    + 抗抵赖性:
        + 你做了 就会留下痕迹
        + 做没做
    + 可核实性:
        + 追溯到谁做了
        + 谁做的
    + 真实性:
        + 双刃剑
    + 依从:
        专门的领域
        数学
        密码学
        etc.
        安全都是相对安全的

        另一个方向: 可信性
+ ## 维护性
    不维护不如做成硬件
    + 模块化:
        + 多个独立组件
        + 组件之间最大正交
        + 高内聚 低耦合
    + 可重用性:
    + 易分析性:
        + 知道是哪儿出毛病了
    + 易修改性:
        + 最好是添加式修改 不是删改
    + 易测试性:
        + 需求必须是可测试的
+ ## 可移植性
    + 兼容性:
    + 可移植性: 从win到unix这样的 重复性是针对单个模块
    + 易安装性:

    + 易替换性:
        + 跨平台
--------

YYY人生经验:

+ 偶尔学很久不如日常俩小时
+ 知道 / 会用 是两回事
+ 反正出去要挨一巴掌 预先知道了就不用惊讶生气了
+ 写代码不要写成一坨 一坨跟屎一样
+ 这种适合比较贱的学生
+ 我的项目都做完了 只剩下钱
+
