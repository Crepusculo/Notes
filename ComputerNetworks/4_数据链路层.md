---
- TOC
---

# 数据链路层

标签（空格分隔）： ComputerNetworks

<!-- MDTOC maxdepth:6 firsth1:1 numbering:0 flatten:0 bullets:1 updateOnSave:1 -->

- [数据链路层](#数据链路层)
- [== 【错误纠正】 ==](#【错误纠正】)
   - [自动重传请求(Automatic Repeat-reQuest,ARQ)](#自动重传请求automatic-repeat-requestarq)
      - [自动重传请求/滑动窗口协议](#自动重传请求滑动窗口协议)
      - [即停模式 (Stop-and-wait) ARQ](#即停模式-stop-and-wait-arq)
      - [回退N帧 (Go-Back-N) ARQ](#回退n帧-go-back-n-arq)
      - [选择性重传 (Selective repeat) ARQ](#选择性重传-selective-repeat-arq)

<!-- /MDTOC -->

 --------------------------------------------------------------------------------

# == 【错误纠正】 ==

## 自动重传请求(Automatic Repeat-reQuest,ARQ)

自动重传请求（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层的错误纠正协议之一。它通过使用**确认**和**超时**这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。

ARQ 可能包括停止等待 ARQ 协议、回退 ARQ 和连续 ARQ 协议，错误检测（Error Detection）、正面确认（Positive Acknowledgment）、超时重传（Retransmission after Timeout）和 负面确认及重传（Negative Acknowledgment and Retransmission）等机制。

传统自动重传请求分为三种
- 即停模式
- 回退N帧
- 选择性重传

后两种协议是滑动窗口技术与请求重发技术的结合，由于窗口尺寸开到足够大时，帧在线路上可以连续地流动，因此又称其为连续 ARQ 协议。三者的区别在于对于出错的数据报文的处理机制不同。三种 ARQ 协议中，复杂性递增，效率也递增。

除了传统的 ARQ，还有混合 ARQ（Hybrid-ARQ）。

- 即停模式: 当发送窗口和接收窗口的大小都等于 1 时，就是停止等待协议。
- 回退N帧: 当发送窗口大于 1，接收窗口等于 1 时，就是回退 N 步协议。
- 选择性重传: 当发送窗口和接收窗口的大小均大于 1 时，就是选择重发协议 。



### 自动重传请求/滑动窗口协议

它们的概念是差不多的只是作用于不同的网络层。数据链路层的滑动窗口是 **"个数固定"** 的。而传输层 TCP 的滑动窗口是 **"个数可变"** 的，可以由接收端设置 WIN 字段来修改。


### 即停模式 (Stop-and-wait) ARQ
![computer_worls_stop_and_wait_arq](..\Resource\computer_worls_stop_and_wait_arq.jpg)

停止并等待协议的工作原理如下：
发送点对接收点发送数据包，然后等待接收点回复 ACK 并且开始计时。
在等待过程中，发送点停止发送新的数据包。
当数据包没有成功被接收点接收时候，接收点不会发送 ACK. 这样发送点在等待一定时间后，重新发送数据包。
反复以上步骤直到收到从接收点发送的 ACK.
发送点的等待时间应当至少大于传输点数据包发送时间（数据包容量除以发送点传输速度），接收点 ACK 接收时间（ACK 容量除以接收点传输速度），数据在连接上的传送时间，接收点检验接收数据是否正确的时间之和。在实际应用当中，等待时间是这个和的 2 到 3 倍。
这个协议的缺点是较长的等待时间导致低的数据传输速度。在低速传输时，对连接频道的利用率比较好，但是在高速传输时，频道的利用率会显著下降。

就是这么蠢! 你不告诉我你收到了 我就不回你QQ! 活该没有女朋友!



### 回退N帧 (Go-Back-N) ARQ
在回退 n 帧的 ARQ 中,允许发送方可以连续发送信息帧, 但是, 一旦某帧发生错误, 必须重新发送该帧及其后的 n 帧。回退 N, 发送窗口大于 1, 接收窗口等于 1。

这种方式提高了信道的利用率, 但允许已发送有待于确认的帧越多, 可能要退回来重发的帧也越多。速度越快, 每次翻船的代价也就越大。尤其是当窗口的长度和带宽时延积都很大，在流水线中会有很多分组时更是如此。一个单个分组的差错就引起 GBN 重传大量分组，而其中的许多分组根本没有必要重传。随着信道差错率的增加，流水线可能会被这些没有必要重传的分组填满。

![computer_worls_stop_and_wait_arq](..\Resource\computer_works_module15-sliding-windows-protocol-and-error-control-31-638.jpg)

>There are a few things to keep in mind when choosing a value for N:
>- The sender must not transmit too fast. N should be bounded by the receiver’s ability to process packets.
>- N must be smaller than the number of sequence numbers (if they are numbered from zero to N) to verify transmission in cases of any packet (any data or ACK packet) being dropped.[2]
>- Given the bounds presented in (1) and (2), choose N to be the largest number possible.[3][not in citation given]



### 选择重传 (Selective repeat) ARQ
发送点连续发送数据包但对每个数据包都设有个一个计时器。
当在一定时间内没有收到某个数据包的 ACK 时，发送点只重新发送那个没有 ACK 的数据包。
当接收方发现某帧出错后，其后继续送来的正确的帧虽然不能立即递交给接收方的高层，但接收方仍可收下来，存放在一个缓冲区中，同时要求发送方重新传送出错的那一帧。一旦收到重新传来的帧后，就可以原已存于缓冲区中的其余帧一并按正确的顺序递交高层。

![Resource\computer_works_module15-sliding-windows-protocol-and-error-control-44-638.jpg](..\Resource\computer_works_module15-sliding-windows-protocol-and-error-control-44-638.jpg)

#### Q: 选择重传协议的滑动窗口大小为什么必须小于或等于序号空间大小的一半？
作者：凌君臣
链接：https://www.zhihu.com/question/23951069/answer/32310526
来源：知乎


我们可以不将序号空间分开看看到底会发生什么
假设 n 取 3,2 的三次方为 8, 序号空间即 0~7
S:sender R:receiver

S 发送了 0,1,3,4,5,6 号帧
R 接受上述帧并且发送 ACKs of 6, 但是丢失了
S 的 0 号帧首先超时，S 重发发送 0 号帧
R 收到 0 号帧，但是因为之前它已经接受 0~6, 发送了 ACKs of 6，它会认为 0 号帧是一个新的帧，而在 0 号帧之前的一个 7 号帧 lost。因为是选择重传协议，R 会接受 0 号帧 (the old) 作为新帧 (暂时放在缓存区)，并通过发送 ACK of 6 通知 S 重发 7 号帧。
S 发送 7 号帧
R 接受了 7 和 0 号帧，并且发送 ACK of 0
这就出现了问题：1、R 接受错误的 0 号帧作为新的帧 2、S 在发送完 7 号帧之后收到了 ACK of 0，S get confused.

出现这个问题的主要原因是我们不能区别新旧帧，现在我们将序号空间一分为二，首先发送 0~3，继续走上面的步骤。走到步骤 4. 的时候 R 不会接受 0 作为新帧，因为 R 知道新的帧是 4 而不是 0。这样就避免了上面的问题。
仅仅避免这个问题其实怎么分是都是可以的，我们可以将序号空间三等分，四等分。。。，但是为了尽可能利用资源，均分为两个部分最佳。

----------------
作者：热爱生活的xyz
链接：https://www.zhihu.com/question/23951069/answer/124468064
来源：知乎
著作权归作者所有，转载请联系作者获得授权。

为了说清楚这个问题，先给出以下两点结论：


1. 帧序号重复使用，但是相同序号内容不同。

2. 发送窗口小于等于接收窗口。

因为发送窗口大于接收窗口部分的帧不能被接收，所以发送窗口大于接收窗口没有意义，故取发送窗口等于接收窗口。
—————————————————————————分割线————————————————————————
现在以 3 比特编码帧序号为例进行解释，则相应的帧序号为 0、1、2、3、4、5、6、7。假设发送窗口为 6 接收窗口也为 6，则发送方可发送序号为 0 到 5 的帧，若接收方全部正确接收了这 6 个帧，并发送了相应的确认帧，则接收方的接收窗口理应更新为 6、7、0、1、2、3。
如果确认帧被接收方正确地接收，则可以正确进行下一次传输。
如果确认帧全部丢失，发送方收不到确认帧，则发送方就会在超时后重传序号为 0 到 5 的帧，而此时接收方的接收窗口已经更新，对于新接收到的序号为 0、1、2、3 的数据帧接收方无法区分是新的数据帧还是旧的数据帧，此时出现二义性。
所以为了避免这种情况，应该令发送窗口为 4，即使确认帧全部丢失，接收窗口和发送窗口也不会重叠。
—————————————————————————分割线————————————————————————
所以当采用 n 比特编码帧序号时，发送窗口的大小最大为 2 的 n-1 次方，这样既保障了传输效率又不会产生二义性。
