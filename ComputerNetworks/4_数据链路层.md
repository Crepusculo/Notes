# 数据链路层

标签（空格分隔）： ComputerNetworks

<!-- MDTOC maxdepth:6 firsth1:1 numbering:0 flatten:0 bullets:1 updateOnSave:1 -->

- [数据链路层](#数据链路层)
- [== [ Logic Link Control, LLC (逻辑链路控制) ] ==](#logic-link-control-llc-逻辑链路控制)
- [== [ MAC, (介质访问控制) ] ==](#mac-介质访问控制)
- [== [ Function of the data link layer ] ==](#function-of-the-data-link-layer)
- [== [ 帧 Framing ] ==](#帧-framing)
- [== [ 错误纠正 ] ==](#错误纠正)
   - [自动重传请求(Automatic Repeat-reQuest,ARQ)](#自动重传请求automatic-repeat-requestarq)
      - [自动重传请求/滑动窗口协议](#自动重传请求滑动窗口协议)
      - [即停模式 (Stop-and-wait) ARQ](#即停模式-stop-and-wait-arq)
      - [回退N帧 (Go-Back-N) ARQ](#回退n帧-go-back-n-arq)
      - [选择重传 (Selective repeat) ARQ](#选择重传-selective-repeat-arq)
         - [Q: 选择重传协议的滑动窗口大小为什么必须小于或等于序号空间大小的一半？](#q-选择重传协议的滑动窗口大小为什么必须小于或等于序号空间大小的一半？)
- [== 【流控制】 ==](#【流控制】)

<!-- /MDTOC -->

 --------------------------------------------------------------------------------


 # == [ Logic Link Control, LLC (逻辑链路控制) ] ==
 是局域网中数据链路层的上层部分
 用户的数据链路服务通过 LLC 子层为网络层提供统一的接口。在 LLC 子层下面是 MAC 子层




# == [ MAC, (介质访问控制) ] ==







# == [ Function of the data link layer ] ==
- **对下**
- To convert the raw bit stream offered by the physical layer into a stream of frames for use by the network layer
- **对上**
- To transfer data from the network layer on the source machine to the network layer on the destination machine.

# == [ 帧 Framing ] ==
# == [ 错误纠正 ] ==

## 自动重传请求(Automatic Repeat-reQuest,ARQ)

自动重传请求（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层的错误纠正协议之一。它通过使用**确认**和**超时**这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。

ARQ 可能包括停止等待 ARQ 协议、回退 ARQ 和连续 ARQ 协议，错误检测（Error Detection）、正面确认（Positive Acknowledgment）、超时重传（Retransmission after Timeout）和 负面确认及重传（Negative Acknowledgment and Retransmission）等机制。

传统自动重传请求分为三种
- 即停模式
- 回退N帧
- 选择性重传

后两种协议是滑动窗口技术与请求重发技术的结合，由于窗口尺寸开到足够大时，帧在线路上可以连续地流动，因此又称其为连续 ARQ 协议。三者的区别在于对于出错的数据报文的处理机制不同。三种 ARQ 协议中，复杂性递增，效率也递增。

除了传统的 ARQ，还有混合 ARQ（Hybrid-ARQ）。

- 即停模式: 当发送窗口和接收窗口的大小都等于 1 时，就是停止等待协议。
- 回退N帧: 当发送窗口大于 1，接收窗口等于 1 时，就是回退 N 步协议。
- 选择性重传: 当发送窗口和接收窗口的大小均大于 1 时，就是选择重发协议 。



### 自动重传请求/滑动窗口协议

它们的概念是差不多的只是作用于不同的网络层。数据链路层的滑动窗口是 **"个数固定"** 的。而传输层 TCP 的滑动窗口是 **"个数可变"** 的，可以由接收端设置 WIN 字段来修改。


### 即停模式 (Stop-and-wait) ARQ
![computer_worls_stop_and_wait_arq](..\Resource\computer_worls_stop_and_wait_arq.jpg)

停止并等待协议的工作原理如下：
发送点对接收点发送数据包，然后等待接收点回复 ACK 并且开始计时。
在等待过程中，发送点停止发送新的数据包。
当数据包没有成功被接收点接收时候，接收点不会发送 ACK. 这样发送点在等待一定时间后，重新发送数据包。
反复以上步骤直到收到从接收点发送的 ACK.
发送点的等待时间应当至少大于传输点数据包发送时间（数据包容量除以发送点传输速度），接收点 ACK 接收时间（ACK 容量除以接收点传输速度），数据在连接上的传送时间，接收点检验接收数据是否正确的时间之和。在实际应用当中，等待时间是这个和的 2 到 3 倍。
这个协议的缺点是较长的等待时间导致低的数据传输速度。在低速传输时，对连接频道的利用率比较好，但是在高速传输时，频道的利用率会显著下降。

就是这么蠢! 你不告诉我你收到了 我就不回你QQ! 活该没有女朋友!



### 回退N帧 (Go-Back-N) ARQ
在回退 n 帧的 ARQ 中,允许发送方可以连续发送信息帧, 但是, 一旦某帧发生错误, 必须重新发送该帧及其后的 n 帧。回退 N, 发送窗口大于 1, 接收窗口等于 1。

这种方式提高了信道的利用率, 但允许已发送有待于确认的帧越多, 可能要退回来重发的帧也越多。速度越快, 每次翻船的代价也就越大。尤其是当窗口的长度和带宽时延积都很大，在流水线中会有很多分组时更是如此。一个单个分组的差错就引起 GBN 重传大量分组，而其中的许多分组根本没有必要重传。随着信道差错率的增加，流水线可能会被这些没有必要重传的分组填满。

![computer_worls_stop_and_wait_arq](..\Resource\computer_works_module15-sliding-windows-protocol-and-error-control-31-638.jpg)

>There are a few things to keep in mind when choosing a value for N:
>- The sender must not transmit too fast. N should be bounded by the receiver’s ability to process packets.
>- N must be smaller than the number of sequence numbers (if they are numbered from zero to N) to verify transmission in cases of any packet (any data or ACK packet) being dropped.[2]
>- Given the bounds presented in (1) and (2), choose N to be the largest number possible.[3][not in citation given]



### 选择重传 (Selective repeat) ARQ
发送点连续发送数据包但对每个数据包都设有个一个计时器。
当在一定时间内没有收到某个数据包的 ACK 时，发送点只重新发送那个没有 ACK 的数据包。

当接收方发现某帧出错后，其后继续送来的正确的帧虽然不能立即递交给接收方的高层，但接收方仍可收下来，存放在一个缓冲区中，同时要求发送方重新传送出错的那一帧。一旦收到重新传来的帧后，就可以原已存于缓冲区中的其余帧一并按正确的顺序递交高层。

![Resource\computer_works_module15-sliding-windows-protocol-and-error-control-44-638.jpg](..\Resource\computer_works_module15-sliding-windows-protocol-and-error-control-44-638.jpg)

#### 窗口
在这个协议中, 发送方和接收方各自维持一个 窗口,
窗口分别包含:
1. 可发送或者已发送但未被确认的序号
2. 可接受的序号

发送方的窗口大小 **从0开始** **增大到某一个预设的最大值**
接收方的窗口 **总是固定不变, 大小等于预先设定的最大值**

接收方为其窗口内的每个序号保留一个缓存区, 每一个缓存区有一个关联的标志位来指明该缓存区是否已满。

每到达一帧, 接受方

检查它的序号, 看是否落在窗口内
如果 1. 确实落在窗口内  2. 以前没有接收过该帧
则 接收该帧 并且 放入缓存区内

不管这帧是否包含了网络层所期望的下一个数据包, 这个过程肯定要执行。
该帧只能保存在数据链路层中, 直到所有序号比它小的帧都已经按序递交给网络层之后, 它才能被传递给网络层


#### Q: 选择重传协议的滑动窗口大小为什么必须小于或等于序号空间大小的一半？
回过头来看其实安德鲁的计网上是讲的最清楚的
抄一下
![CN_4_1][CN_4_1]
非顺序接收引发了一些按顺序接收帧的协议不用考虑的特殊问题。我们用一个例子就很容易说明麻烦之处。
1. 假设我们用 3 位二进制序号, 那么发送方允许连续发送 7 个帧, 然后开始等待确认, 一开始 发送方和接收方的窗口如上图(a)所示
2. 现在发送方发出 0~6号 帧
3. 接收方的窗口允许它接收任何序号落在0~6之间的帧
4. 这7帧全部都正确的到达了
5. 接收方进行确认, 向前移动它的窗口, 允许接收7,0,1,2,3,4,5 帧2,如上图(b)所示。 此时, 这7个缓存区都标记为空。
6. 此时灾难降临了闪电击中了电线杆子,所有的确认都被摧毁。(原话)
7. 协议应该不管灾难是否发生都能继续工作, 协议A了上去。
8. 发送方超时, 重发 0 号帧。
9. 帧到达接收方,
10. 检查序号, 不幸发生了, 0 落在新窗口中, 所以它被当做新帧接收了。
11. 接收方同样返回 6 号帧确认, 因为 0~6号帧都已经接收到了
12. 发送方很高兴地得知它所发出去的帧都已经正确地到达了, 并立即发送 7,0,1,2,3,4,5 号帧。
13. 7号帧将被接收方接收, 并且它的数据包直接传递给网络层
14. 数据链路层进行下一步检查, 看是否有一个有效的0号帧
15. 然后它发现有了 (即前面重发的0号帧)
16. 然后把内嵌的数据包作为新的数据包发给网络层
17. 网络层得到一个不正确的数据包, GG

这个问题的本质是 当接收方向前移动它的窗口后, 新的有效范围与老的序号范围有重叠。因此, 后续的一批帧可能是重复的帧(如果所有的确认都丢失了),也可能是新的帧(如果所有的确认都收到了)。可怜的接收方根本无法区分这两种情形。(原话)

// 这个凌君臣的答案其实是抄的Andrew那本计网的内容
> 作者：凌君臣
> 链接：https://www.zhihu.com/question/23951069/answer/32310526
> 来源：知乎
> 我们可以不将序号空间分开看看到底会发生什么
> 假设 n 取 3,2 的三次方为 8, 序号空间即 0~7
> S:sender R:receiver
> S 发送了 0,1,3,4,5,6 号帧
> R 接受上述帧并且发送 ACKs of 6, 但是丢失了
> S 的 0 号帧首先超时，S 重发发送 0 号帧
> R 收到 0 号帧，但是因为之前它已经接受 0~6, 发送了 ACKs of 6，它会认为 0 号帧是一个新的帧，而在 0 号帧之前的一个 7 号帧 lost。因为是选择重传协议，R 会接受 0 号帧 (the old) 作为新帧 (暂时放在缓存区)，并通过发送 ACK of 6 通知 S 重发 7 号帧。
> S 发送 7 号帧
> R 接受了 7 和 0 号帧，并且发送 ACK of 0
> 这就出现了问题：1、R 接受错误的 0 号帧作为新的帧 2、S 在发送完 7 号帧之后收到了 ACK of 0，S get confused.
> 出现这个问题的主要原因是我们不能区别新旧帧，现在我们将序号空间一分为二，首先发送 0~3，继续走上面的步骤。走到步骤 4. 的时候 R 不会接受 0 作为新帧，因为 R 知道新的帧是 4 而不是 0。这样就避免了上面的问题。
> 仅仅避免这个问题其实怎么分是都是可以的，我们可以将序号空间三等分，四等分。。。，但是为了尽可能利用资源，均分为两个部分最佳。

----------------
> 作者：热爱生活的xyz
> 链接：https://www.zhihu.com/question/23951069/answer/124468064
> 来源：知乎
> 著作权归作者所有，转载请联系作者获得授权。
> 为了说清楚这个问题，先给出以下两点结论：
> 1. 帧序号重复使用，但是相同序号内容不同。
> 2. 发送窗口小于等于接收窗口。
> 因为发送窗口大于接收窗口部分的帧不能被接收，所以发送窗口大于接收窗口没有意义，故取发送窗口等于接收窗口。
> —————————————————————————分割线————————————————————————
> 现在以 3 比特编码帧序号为例进行解释，则相应的帧序号为 0、1、2、3、4、5、6、7。假设发送窗口为 6 接收窗口也为 6，则发送方可发送序号为 0 到 5 的帧，若接收方全部正确接收了这 6 个帧，并发送了相应的确认帧，则接收方的接收窗口理应更新为 6、7、0、1、2、3。
> 如果确认帧被接收方正确地接收，则可以正确进行下一次传输。
> 如果确认帧全部丢失，发送方收不到确认帧，则发送方就会在超时后重传序号为 0 到 5 的帧，而此时接收方的接收窗口已经更新，对于新接收到的序号为 0、1、2、3 的数据帧接收方无法区分是新的数据帧还是旧的数据帧，此时出现二义性。
> 所以为了避免这种情况，应该令发送窗口为 4，即使确认帧全部丢失，接收窗口和发送窗口也不会重叠。
> —————————————————————————分割线————————————————————————
> 所以当采用 n 比特编码帧序号时，发送窗口的大小最大为 2 的 n-1 次方，这样既保障了传输效率又不会产生二义性。
#### 接收方必须拥有多少个缓存区
接收方不可能接受序号低于窗口下界的帧
接收方也不可能接受高于窗口上界的帧

因此所需要的缓存区数量等于窗口的大小, 而不是序号的范围。
对于一个3位序号的例子, 只要4个缓存区就够了, 编号为0~3, 当第i帧进入的时候放在第(i mod 4 )号缓存区里

i 和 (i+4) 竞争同一个缓存区, 但他们永远不会同时落在窗口内, 因为如果那样的话则窗口的尺寸至少为5.
#### 计时器的数量
同理, 计时器只要能对每一个缓冲区进行计时即可。
因此所需要的计时器数量等于窗口的大小和缓冲区的数量, 而不是序号的范围。

#### 计时器 / 辅助计时器 / NAK
对应的是选择重传不同协议中对于丢失帧检验重传的不同方法, 也可以混合使用。

# == 【流控制】 ==

[CN_4_1]:..\Resource\computer_works_4_1.jpg
