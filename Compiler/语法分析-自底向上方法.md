# 自底向上方法

<!-- MDTOC maxdepth:6 firsth1:1 numbering:0 flatten:0 bullets:1 updateOnSave:1 -->

- [自底向上方法](#自底向上方法)
- [优先分析方法](#优先分析方法)
   - [简单优先法](#简单优先法)
   - [算术优先法](#算术优先法)
- [==!== LR 方法](#lr-方法)
         - [扩展:句柄 句子 句型 短语](#扩展句柄-句子-句型-短语)
         - [移进-规约 分析法 | 自底向上方法](#移进-规约-分析法-自底向上方法)
            - [分析过程:](#分析过程)
            - [实现](#实现)
      - [[ 4.3.3 ] LR分析器](#433-lr分析器)
         - [[ 4.3.3.2 ] LR 分析器的模型及工作过程](#4332-lr-分析器的模型及工作过程)
            - [分析表](#分析表)
         - [[ 4.3.3.3 ] SLR 分析器的构造 | 简单](#4333-slr-分析器的构造-简单)
         - [[ 4.3.3.4 ] LR(1) 分析表的构造 | 复杂 功能强大 代价高](#4334-lr1-分析表的构造-复杂-功能强大-代价高)
         - [[ 4.3.3.5 ] LALR 分析表的构造 | 代价低 功能强大](#4335-lalr-分析表的构造-代价低-功能强大)
         - [[ 4.3.3.6 ] LR 分析方法对二义文法的应用](#4336-lr-分析方法对二义文法的应用)
         - [[ 4.3.3.7 ]](#4337)

<!-- /MDTOC -->

对输入串的扫描:
    - 自左向右
分析树的构造:
    - 自底向上
分析过程:
    - 从输入符号串开始分析
    - 查找当前句型的"可规约串"
    - 使用规则, 把它归约成相应的非终结符号
    - 重复
关键: 找出可归约串

# 优先分析方法
## 简单优先法
## 算术优先法
# ==!== LR 方法
### 可规约串:

+ 可规约串是句柄
+ 句柄: 最左直接短语

**特点**

+ 分析过程是一种规范规约
    + (最右推导,最左规约)
    + 最右推导是规范推导
        + 不同的最右推导,其逆过程也是不同的
    + 最左规约``是规范规约
    + 规范句型的特点: 句柄之后没有非终结符号
+ 速度快
+ 能及时准确地指出出错位置
+ 适用于大多数无二义文法
+ 完备
    + 是最一般的无回溯的"移进规约"分析方法
    + 可以分析所有能用上下文无关文法书写的程序设计语言结构
    + 是预测分析法能分析的文法的真超集

**不提取公因子,不消除左递归**


#### 扩展:句柄 句子 句型 短语 直接短语
1、短语：子树的末端结点形成的符号串．
这个短语相对的句型：整个树的末端结点．
非终结符号：子树的根
2、简单子树：只有一层分支的子树
3、简单短语：简单子树的末端结点形成的符号串．
4、句柄：子树中最左边的那棵只有父子两代的子树的所有叶结点自左至右排列起来，就是该句型的句柄

**句柄的概念(李文生PPT)**
句型:
对于文法**G=（Vt,Vn,S,φ）**, 如果 **S=>\*α**,则称**α**为当前文法的一个句型

短语:
对于文法**G=（Vt,Vn,S,φ）**,假定**αβγ**是文法**G**的一个句型，如果存在**S=>\* αAδ**,并且**A=>+β**,则称β是句型αβγ关于非终结符**A**的短语

直接短语:
对于文法**G=（Vt,Vn,S,φ）**,假定**αβγ**是文法G的一个句型，如果存在**S=>\* αAδ**,并且**A=>β**,则称**β**是句型**αβγ**关于非终结符**A**的直接短语

一个句型的最左直接短语称为该句型的句柄


#### 移进-规约 分析法 | 自底向上方法
符号栈: 存放文法符号

##### 分析过程:
1. 把输入符号一个个**移进**栈中。
2. 当栈顶的符号串形成某个产生式的一个候选式时, 在一定条件下, 把该符号替换(即**规约**)为该生成树的左部符号。
3. 重复 2. 直到栈顶符号串不再是"可规约串"为止。
4. 重复 1.-3. 直到最终规约出开始符号**S**。

##### 规范规约
定义：假定α是文法G的一个句子，我们称右句型序列 αn，αn-1，…，α1，α0  是α的一个规范归约，如果序列满足：
(1) αn=α，α0=S
(2) 对任何I( 0< i ≤ n)，αi-1是经过把αi的句柄替换为相应产生式的左部符号而得到的。
规范归约是关于α的一个最右推导的逆过程，因此规范归约也称为最左归约。

abbcde的一个规范归约是如下的右句型序列：abbcde，aAbcde，aAcde，aAcBe，S。

##### 句柄的最左性
##### ==!==不同的最右推导，其逆过程也是不同
例：考虑文法 E→E+E|E*E|(E)|id的句子id+id*id
（1）$E\Rightarrow E+E\Rightarrow E+E*E\Rightarrow E+E*id\Rightarrow E+id*id\Rightarrow id+id*id $
（2）$E\Rightarrow E*E\Rightarrow E*id\Rightarrow E+E*id\Rightarrow E+id*id\Rightarrow id+id*id$
对于句型E+E*id：
（1）在推导一中，句柄为id
（2）在推导二中，句柄为E+E
规范归约的关键问题是找句柄，给出了寻找句柄的方法，就给出了规范归约的方法

##### 实现

1. 分析开始时,先将$符号入栈,以示栈底 [栈]
2. 将 $ 置于输入的符号串之后, 表示输入符号串的结束 [输入符号串]
3. 在分析过程中，将输入放入栈中，判断是否构成可归约串，如果是，则将这个子串用相应的归约符号进行替换
4. 重复此过程，直到栈顶不再呈现可归约串为止，然后继续向栈中移进符号
5. 重复整个过程，直到形成结束格局为止
6. 如果达不到这个状态，表示有错误

**对符号栈的四个动作:**
移进
规约
接受
错误处理

**冲突:**
移进-规约 冲突
规约-规约 冲突

例: 对abbcde
```
1)  S→aAcBe
2)  A→b
3)  A→Ab
4)  B→d
```
进行归约

![Resource\cp_2_1.jpg][1]

### ==!==LR分析器
LR 分析技术介绍

+ LR(k)的含义
    + `L` 表示**自左向右扫描**输入符号串
    + `R` 表示为输入符号串构造一个**最右推导的逆过程**
    + `k`表示为作出分析决定而**向前看的输入符号的个数**
+ LR分析方法的基本思想
    + **"历史信息"**:记住已经移进和归约出的整个符号串
    + **"预测信息"**:根据所用的产生式推测未来可能遇到的输入符号
    + 根据"历史信息""预测信息"和"现实"的输入符号，确定栈顶的符号串是否构成相对于某一产生式的句柄。

**LR分析技术是一种比较完备的技术**
    - 可以分析所有能用上下文无关文法书写的程序设计语言的结构；
    - 最一般的**无回溯**的**"移进-归约"**方法；
    - 能分析的文法类是预测分析方法能分析的文法类的真超集；
    - 分析过程中，能及时发现错误，快到自左至右扫描输入的最大可能。

LR分析方法的不足之处
    - 手工编写LR分析器的工作量太大
    - 需要专门的工具，即LR分析器生成器（如YACC）


## [ =1= ] LR 分析器的模型及工作过程

五个部分 输入 栈 输出 分析表 控制程序
![Resource\cp_2_LR][2]
**$goto[S_m，X]$**：状态Sm经X转移的一个状态
**$action[S_m，a_i]$**：状态Sm面临输入符号ai时应采取的分析动作
移进：把当前输入符号ai及由Sm和ai所决定的下一个状态**S=goto[Sm，ai]**推进栈，向前扫描指针前移。
归约：用某产生式**A→β**进行归约，若的长度为r，归约的动作从栈顶起向下弹出2r项，使Sm-r成为栈顶状态，然后把文法符号A及状态**S=goto[Sm-r，A]**推进栈。
接受：宣布分析成功，停止分析。
出错：调用出错处理程序，进行错误恢复。

输入：文法G
输出：G的LR(0)项目集规范族C
方法：
```
begin
C:={closure({S’·S})};
repeat
   for  对C中的每一个项目集I和每一个文法符号X  do
      if  go(I,X)不为空，且不在C中  then
          把go(I,X)加入C中
until  没有更多的项目集加入C中
end.
```
这里closure({S’→·S})是活前缀 ε 的有效项目集

例子: 构造如下文法G的LR(0)项目集规范族：
 `S→aA|bB`   `A→cA|d`   `B→cB|d`

## [ =2= ] ==!==SLR 分析器的构造 | 简单
SLR分析方法的一个特征
- 如果文法的有效项目集中有冲突动作，多数冲突可通过考察有关非终结符号的FOLLOW集合而得到解决
-
如项目集：**$I={X\to\alpha·b\beta, A\to\alpha·, B\to \alpha·}$**
存在移进-归约冲突
存在归约-归约冲突

==!==冲突的解决方法，查看 **FOLLOW(A)** 和 **FOLLOW(B)**
- **FOLLOW(A)$\cap$FOLLOW(B)=$\phi$**
- **b ∉ FOLLOW(A) 并且 b ∉ FOLLOW(B)**
- 也就是说 FOLLOW(A),FOLLOW(B)和b交集为空
- 决策:
    - 当 a=b 时, 把 b 移进栈里
    - 当 a ∉ FOLLOW(A)时，用产生式 $A\to\alpha·$ 进行归约；
    - 当 a ∉ FOLLOW(B)时，用产生式 $B\to \alpha·$ 进行归约。

### ==!==构造 SLR 分析表
我们现在已经得到了拓广文法G'和它的规范族$C=\{I_0, I_1,..., I_2\}$了, 接下来再接再厉
**s - shift**
**r - reduce**
对于 **$I_i$** 的状态 **i** 的分析动作如下
- 如果 **$A \to \alpha · a \beta \in I_i $**, 且**$go(I_i,a) = I_j$**
    - 置 **action[i,a] = s j**
- 如果 **$A \to \alpha ·\in I_i$**
    - 对所有的 **$ a \in FOLLOW(A)$**, 置**action[i,a] = $r _{A\to\alpha}$**
- 如果 **$S'\to S· \in I_i$**
    - 置 **action[i,$]=acc** 表示分析成功
- 若 **$go(I_i , A)=I_j$** A  为非终结符号,
    - 置 **goto[i, A] = k**

凡不能用以上规则填入信息的空白表项，均置为出错标志error。
分析器的初态是包含项目S’→S的有效项目集所对应的状态。


## [ =3= ] ==!==LR(1) 分析表的构造 | 复杂 功能强大 代价高
## [ =4= ] ==!==LALR 分析表的构造 | 代价低 功能强大
## [ =5= ] ==!==LR 分析方法对二义文法的应用



[1]:..\Resource\cp_2_1.jpg
[2]:..\Resource\cp_2_LR.jpg
