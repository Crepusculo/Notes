
<!-- MDTOC maxdepth:6 firsth1:1 numbering:0 flatten:0 bullets:1 updateOnSave:1 -->

- [== [ 自顶向下分析方法 | Top-down parsing ] ==](#自顶向下分析方法-top-down-parsing)   
   - [★ 递归下降分析](#★-递归下降分析)   
      - [例子:试分析输入串 $\omega = cad$ 是否为如下文法的一个句子。](#例子试分析输入串-omega-cad-是否为如下文法的一个句子。)   
      - [Q&A](#qa)   
            - [为什么采用最左推导？](#为什么采用最左推导？)   
            - [如何实现](#如何实现)   
      - [总结](#总结)   
   - [★ 非递归预测分析](#★-非递归预测分析)   
      - [Q&A](#qa)   
            - [如何克服回溯？](#如何克服回溯？)   
            - [对文法的要求 | 消除左递归](#对文法的要求-消除左递归)   
            - [预测分析器的构造](#预测分析器的构造)   

<!-- /MDTOC -->

地位那些杂七杂八的东西我们就略过了

# == [ 自顶向下分析方法 | Top-down parsing ] ==
自顶向下方法是一种面向目标的分析方法。
分析时,**从文法的开始符号出发**, 进行**推导**, 试图推导出于要分析的输入符号串完全匹配的句子, (否则转入错误处理)。

## ★ 递归下降分析
- 从文法的**开始符号**出发, **向下推导**, 试图推出要分析的输入串的过程:
- 对给定的输入串, 从对应文法开始符号的根节点出发, 自顶向下地为输入串建立一棵分析树
- **试探过程, 是反复使用不同产生式谋求匹配输入串的过程。**
- **有回溯**, 试探失败时回溯

### 例子:试分析输入串 $\omega = cad$ 是否为如下文法的一个句子。

$ S \to cAd $
$ A \to ab | a $
![Resource\cp_1.jpg][1]

$ S \to cAd \to cad $
试图为输入符号串建立一个最左推导序列的过程。

### Q&A

##### 为什么采用最左推导？
> 因为对输入串的扫描是自左至右进行的，只有使用最左推导，才能保证按扫描的顺序匹配输入串。

##### 如何实现
> - 文法的每一个非终结符号对应一个递归过程，即可实现这种带回溯的递归下降分析方法。
> - 每个过程作为一个布尔过程，一旦发现它的某个产生式与输入串匹配，则用该产生式展开分析树，并返回true，否则分析树不变，返回false。

### 总结
实践中存在的困难和缺点
- 左递归的文法，可能导致分析过程陷入死循环。
- 成功是虚假的、暂时的，需要回溯
-  回溯需要将一些语义动作推倒重来
    - 各种表格的记录内容
    - 中间代码的产生
    - 费时麻烦
    - 有些动作无法回溯
- 是穷尽一切可能的试探法
    - 效率低
    - 代价高
    - 使用价值有限
    -
## ★ 非递归预测分析
- 无回溯
### Q&A
##### 如何克服回溯？
> 能够根据所面临的输入符号准确地指派一个候选式去执行任务。
该选择的工作结果是确信无疑的。
>
> 通过预读来确定唯一指定的右侧
>
> 例：
$A \to \alpha_1| \alpha 2|...|\alpha_n $
当前输入符号：a
指派$\alpha_i$去匹配输入符号串

##### 对文法的要求 | 消除左递归
***PART. 1 对文法的要求***
> **一。不含左递归**
>
> **1. 直接左递归 (Immediate left recursion)**
> **$ A \to A\alpha \space|\space \beta$**
> 这里 $\alpha$  跟  $\beta$  代表不同的非终端符号跟终端符号组成的序列，并且 $\beta$  不一定要包含 $A$ 举例来说，以下规则
> $Expr \to Expr + Term $
就是一个直接左递归的例子。这规则的*递归下降分析器*可能会像这样:
> ```{c}
> fuction Expr()
> {
>   Expr(); match('+'); Term();
> }
> ```
> 然后这个递归下降分析器在尝试去解析包含此规则的文法时，会陷入一个无穷的递归。
>
> **2. 间接左递归 (Indirect left recursion)**
> 间接左递归 (indirect left recursion) 最简单的形式如下：
> **$ A \to B\alpha \space|\space C$**
> **$ B \to A\beta \space|\space D_1$**
> 这规则可能产生形如 $ A \to B\alpha \to A\beta\alpha \to ...$ 这样的生成
> 简单的说，间接左递归就是，并非在一条规则内完成左递归，而是在许多条规则之后，于产生的句子最左边出现了一开始的非终端符号。
更一般化的说法，对非终端符号 $ A_0, A_1, \ldots, A_n$，间接左递归被定义为以下的型态：
> **$ A_0 \to A_1\alpha_1 \mid \ldots $
$ A_1 \to A_2\alpha_2 \mid \ldots $
$ \cdots $
$ A_n \to A_0\alpha_{n+1} \mid \ldots  $**
> 这里的 $ \alpha_1, \alpha_2, \ldots, \alpha_n $都是一堆终端与非终端符号的序列。


> **二。$ FIRST (\alpha_i) \cap FIRST(\alpha_j)$**
>
***PART. 2 消除左递归***
一个一般化后移除直接左递归的算法如下所述。 这个方法已经有过许多的改进，包括 Robert C. Moore 所撰写，名为 "Removing Left Recursion from Context-Free Grammars" 的改进。
对于每个规则如下
**$$  A \to A\alpha_1\,|\,\ldots\,|\,A\alpha_n\,|\,\beta_1\,|\,\ldots\,|\,\beta_m $$**
(注意这里：
- **A** 是一个有左递归的非终端符号
- **$ \alpha $** 是一个终端与非终端符号的序列，而且不为空字串 ( $  \alpha \ne \epsilon $)
- **$ \beta$**  是一个不以 **A** 开头的，以终端与非终端符号组成的序列)

将 A 的规则改成以下规则：
**$ A \rightarrow \beta_1A^\prime\, |\, \ldots\,  |\,  \beta_mA^\prime $**
然后对新创造出来非终端符号的规则
**$ A^\prime \rightarrow \epsilon\, |\, \alpha_1A^\prime\,  |\,  \ldots\, |\, \alpha_nA^\prime
$**
这个新创造出来的符号常被称为 "尾巴"(tail)，或者 "rest"(剩余)

举例，考虑以下规则
**$ Expr \rightarrow Expr\,+\,Expr\,|\,Int\,|\,String $**
我们可以改写为
**$ Expr \rightarrow Int\,ExprRest\,|\,String\,ExprRest
$**
**$ExprRest \rightarrow \epsilon\,|\,+\,Expr\,ExprRest $**
然后最后一个规则可以缩短改写为
**$ExprRest \rightarrow \epsilon\,|\,+\,Expr$**
来避免掉左递归的出现
***PART. 3 消除间接左递归***
如果文法内不存在 $ \epsilon $(代表空字串) 的生成 (不存在 $ A \rightarrow \ldots | \epsilon | \ldots $ 这样的规则)，而且不是循环 (cyclic) 的文法 (对所有非终端符号 A，不存在像是 $ A \Rightarrow  \ldots \Rightarrow A $ 这种形式的规则)，以下这个一般化的算法可以用来去除文法的间接左递归：
将所有非终端符号以某个固定的顺序 $ A_1, \ldots A_n $ 排列


- 从 i = 1 到 n {
    - 从 j = 1 到 i – 1 {
        - 设 $A_{j}$ 的生成规则为
$ A_j \rightarrow \delta_1 | \ldots | \delta_k$
        - 将所有规则 $ A_i \rightarrow A_j \gamma $ 换成
$ A_i \rightarrow \delta_1\gamma | \ldots | \delta_k\gamma$
移除 $ A_{i}$ 规则中的直接左递归
    - }
- }


##### 预测分析器的构造

[1]:..\Resource\cp_1.jpg
