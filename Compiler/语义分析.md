# 语义分析

<!-- toc orderedList:0 depthFrom:1 depthTo:6 -->

* [语义分析](#语义分析)
        * [符号表](#符号表)
        * [信息的引用](#信息的引用)
        * [静态检查](#静态检查)
        * [类型检查](#类型检查)
        * [控制流检查](#控制流检查)
        * [唯一性检查](#唯一性检查)
        * [关联名字检查](#关联名字检查)
        * [动态检查](#动态检查)
    * [建立和访问符号表的时机](#建立和访问符号表的时机)
    * [符号表的内容](#符号表的内容)
    * [在符号表上的操作](#在符号表上的操作)
    * [符号表的组织](#符号表的组织)
    * [==[ ! ]== 类型检查 - 类型表达式](#类型检查-类型表达式)
* [存储组织](#存储组织)
    * [活动记录](#活动记录)
    * [静态](#静态)
    * [栈式](#栈式)
    * [堆式](#堆式)
    * [访问非局部名字](#访问非局部名字)

<!-- tocstop -->
### 符号表
记录编译过程中识别出的上下文有关的信息，如：
+ 变量的类型
+ 相对地址

符号表在翻译过程中起两方面的重要作用：

+ 检查语义（即上下文有关）的正确性
+ 辅助正确地生成代码

通过在符号表中插入和检索变量的属性来实现的
符号表是一张动态表

+ 在编译期间符号表的入口不断地增加
+ 在某些情况下又在不断地删除

编译器需要频繁地与符号表进行交互，符号表的效率直接影响编译器的效率。

### 信息的引用
根据词法分析器识别出的标识符的属性值（标识符在符号表中的入口），查找符号表中对应该标识符的记录，从而可以取得该标识符有关的信息。
如果编译的程序块处于该变量的作用域内，则这个变量将一直保留在符号表中
### 静态检查
读入源程序、但不执行源程序的情况下进行的检查
### 类型检查
对访问数据的操作和被访问数据的类型进行检查，检查操作的合法性和数据类型的相容性。

+ 由类型检查器完成
+ 检验结构的类型是否和它的上下文所期望的一致
    + 算术运算符mod
    + 用户定义的函数
+ 类型检查器的位置
![check_pos](/assets/check_pos.png)
+ 生成目标代码时可能用到类型检查器产生的信息
    + 重载运算符：一个运算符在不同的上下文中表示不同的运算
    + 类型强制：编译器把运算对象变换为上下文所期望的类型

### 控制流检查
### 唯一性检查
### 关联名字检查
### 动态检查
## 建立和访问符号表的时机
![duobian](/assets/duobian.png)

![hebingbian](/assets/hebingbian.png)

## 符号表的内容
符号表中记录的是和标识符相关的属性
出现在符号表中的属性种类，在一定程度上取决于程序设计语言的性质。
符号表的典型形式：

变量名    目标地址  类型  维数  声明行    引用行    指针

__交叉引用表__
变量名    类型   维数  声明行   引用行

## 在符号表上的操作
## 符号表的组织

## ==[ ! ]== 类型检查 - 类型表达式
基本类型 是 __类型表达式__
类型名 是 __类型表达式__
类型构造器 作用于 类型表达式 的结果__仍是__ 类型表达式
+ __数组__:
    + 代码`var  A:array[1..10] of integer;`
    + 类型表达式`array(1..10,integer)`
    + 如果T是类型表达式，那么`array(I，T)`是元素类型为`T`和下标集合为`I`的数组的__类型表达式__，`I`通常是一个整数域。
+ __笛卡尔乘积__:
    + 如果T1和T2是类型表达式，那么它们的笛卡儿乘积T1xT2也是类型表达式，假定x是左结合的。
+ __记录__:
    + 记录类型是它的各域类型的笛卡儿乘积
  把类型构造器record作用于由域名和与之相关的类型表达式组成的二元组，就形成记录的类型表达式

```
type  row=record
            address:integer;
            lexeme:array[1..15] of char
        end;
```
有类型表达式:
```
record((address x integer)x(lexeme x array(1..15,char)))
```
+ __指针__: 如果T是类型表达式，那么`pointer(T)`是类型“指向类型T的对象的指针”的类型表达式。
```
var p:↑row;
```
与P相关的类型表达式为：
```
pointer(row)
```
+ __函数__: 从定义域类型D到值域类型R的映射
    + 类型由类型表达式 D$\to$R 表示。
用户定义的Pascal函数：
```
function f(a,b:char):↑integer;
```
f的类型表达式：
```
char x char → pointer(integer)
```

函数g：
参数是把整数映射成整数的函数
返回结果是和参数类型相同的另一函数
g的类型表达式为：
```
    (integer→integer)→(integer→integer)
```

# 存储组织
## 活动记录
保存过程在一次执行中所需信息的一个连续的存储块
|||
| ----- | :--
| __返回值__ | `本活动返回给调用过程的值`
| __实参区域__ |   `调用过程提供给本活动的参数值`
| __控制链__ |    `指向调用过程的活动记录的指针, 用于本活动结束时的恢复`
| __访问链__ | `指向直接外围过程的最近一次活动的活动记录的指针，用于对非局部名字的访问`
| __机器状态域__ | `保存断点的现场信息，寄存器、PSW等`
| __局部数据区__ | `在本次活动中，为过程中定义的局部变量分配的存储空间`
| __临时数据区__ | `存放中间计算结果`

## 静态
## 栈式
## 堆式
__如果具体的存储需求在编译时刻可以确定__
——采取静态存储分配策略

__如果某些存储需求在编译时不能确定，但在程序执行期间，在程序的入口点上可以知道__
——采用栈式存储分配策略

栈式存储分配策略不能处理的存储需求：
+ 程序设计语言中的某些数据结构的存储需求
+ 活动停止时局部名字的值必须被保存下来
+ 被调用过程的活动生存期超过调用过程的生存期，这种语言的过程间的控制流不能用活动树正确地描述。

__共性：活动记录的释放不需要遵循先进后出的原则__


## 访问非局部名字
对非局部名字的引用取决于 __作用域规则__
静态作用域规则：词法作用域规则、__最近嵌套__ 规则
动态作用域规则：由运行时最近的活动决定可应用到一个名字上的声明

对非局部名字的访问通过__访问链__实现
关键：访问链如何创建、使用、维护

4个模式
- 程序块
- 非嵌套过程的静态作用域
- 嵌套过程的静态作用域
- 动态作用域
