# 语法制导翻译技术

---

<!-- MDTOC maxdepth:6 firsth1:1 numbering:0 flatten:0 bullets:1 updateOnSave:1 -->

- [语法制导翻译技术](#语法制导翻译技术)   
- [定义](#定义)   
- [形式](#形式)   
   - [eg.](#eg)   
   - [综合属性](#综合属性)   
   - [继承属性](#继承属性)   
   - [==[ ! ]==构造依赖图](#构造依赖图)   
      - [计算次序](#计算次序)   
   - [S - 属性定义的自底向上翻译](#s-属性定义的自底向上翻译)   
      - [语法树](#语法树)   
      - [构造表达式的语法树](#构造表达式的语法树)   
      - [构造表达式的语法树的语法制导定义](#构造表达式的语法树的语法制导定义)   
      - [表达式的有向非循环图（dag）](#表达式的有向非循环图（dag）)   
      - [S属性定义的自底向上实现](#s属性定义的自底向上实现)   
      - [例：用LR分析器实现台式计算器](#例：用lr分析器实现台式计算器)   
   - [L属性](#l属性)   
      - [L属性的计算: 深度优先](#l属性的计算-深度优先)   
      - [设计翻译方案](#设计翻译方案)   
   - [L - 属性定义的自顶向下翻译](#l-属性定义的自顶向下翻译)   
      - [消除左递归](#消除左递归)   
      - [例子](#例子)   
      - [从上述方法们得到的翻译方案 得到 程序](#从上述方法们得到的翻译方案-得到-程序)   
   - [L - 属性定义的自底向上翻译](#l-属性定义的自底向上翻译)   
      - [一 从翻译方案中去掉嵌入的动作](#一-从翻译方案中去掉嵌入的动作)   
      - [二 分析栈中的继承属性](#二-分析栈中的继承属性)   
      - [三 模拟继承属性的计算](#三-模拟继承属性的计算)   
      - [四 用综合属性代替继承属性](#四-用综合属性代替继承属性)   

<!-- /MDTOC -->

---

# 定义

根据产生式包含的语义，分析文法中每个符号的语义
把这些语义以**属性**的形式附加到相应的文法符号上
根据产生式的语义，给出符号间属性的求值规则(即**语义规则**)，从而形成__语法制导定义__。

# 形式
对于每一个文法产生式 $A \to \alpha$
都有与之对应的一套语义规则 形式为 $b = f(c_1,c_2,...,c_k)$
其中

+ $f$ 是一个函数
+ $b$
    + 是 **A的一个综合属性** 且 $c_1,c_2,...c_k$是产生式右部文法符号的属性
    + 或者是产生式 **右部某个文法符号的一个继承属性** 且$c_1,c_2,...,c_k$__是A__或产生式右部文法符号的属性。

## eg.
| 产生式 | 语义规则 |
|--|--|
| $L\to En    $|  print(E.val)
| $E\to E1+T  $|  E.val:=E1.val+T.val
| $E\to T     $| E.val:=T.val
| $T\to T1*F  $| T.val:=T1.val*F.val
| $T\to F     $| T.val:=F.val
| $F\to (E)   $| F.val:=E.val
| $F\to digit $|  F.val:=digit.lexval
__综合属性val与每一个非终结符号E、T、F相联系__
表示相应非终结符号所代表的子表达式的整数值

$L\to E
n$的语义规则是一个过程，打印出由E产生的算术表达式的值，可以认为是非终结符号L的一个虚拟综合属性。

## 综合属性
一个结点的某一属性由其子结点的属性确定，则这种属性为该结点的__综合属性__。

如果一个语法制导定义仅仅使用综合属性，则称这种语法制导定义为__S-属性定义__。

对于S-属性定义，通常采用自底向上的方法对其分析树加注释，即从树叶到树根，按照语义规则计算每个结点的属性值。

## 继承属性
分析树中，一个结点的__继承属性__值由该结点的 __父结点和/或它的兄弟结点__ 的属性值决定。
可用继承属性表示程序设计语言结构中上下文之间的依赖关系
+ 可以跟踪一个标识符的类型
+ 可以跟踪一个标识符，了解它是出现在赋值号的右边还是左边，以确定是需要该标识符的值还是地址

## ==[ ! ]==构造依赖图
依赖图表现的是 结点的继承属性和综合属性之间的相互依赖关系
为每个包含过程调用的语义规则引入一个__虚拟综合属性b__，以便把语义规则统一为$b:=f(c_1,c2,...,ck)$的形式。

__依赖图中：__
为每个属性设置一个结点
如果属性b依赖于c，那么从属性c的结点有一条有向边连到属性b的结点。

__输入:__ 一颗分析树
__输出:__ 一张依赖图
__方法:__

```py
for 分析树中每一个结点n do:
    for 结点n处的文法符号的每一个属性a do:
        为a在依赖图中建立一个结点

for 分析树中每一个结点n do:
    for 结点n处所用产生式对应的每一个语义规则 b:=f(c1,c2,…ck)do:
        for i:=1 to k do:
            从ci结点到b结点 构造一条有向边
```

### 计算次序
有向非循环图的拓扑排序
+ 图中结点的一种排序 $m_1,m_2,...,m_k$
+ 有向边只能从这个序列中前边的结点指向后面的结点
+ 如果 $m_i \to m_j$ 是从 $m_i$ 指向 $m_j$ 的一条边，那么在序列中mi必须出现在mj之前。

依赖图的任何拓扑排序
+ 给出了分析树中结点的语义规则计算的有效顺序
+ 在拓扑排序中，一个结点上语义规则 $b:=f(c1,c2,...,ck)$ 中的属性c1,c2,…,ck在计算b时都是可用的。
![yilaitu](/assets/yilaitu.png)
拓扑排序：
1、2、3、4、5、6、7、8、9、10
4、5、3、6、7、2、8、9、1、10
从拓扑排序中可以得到下面的程序，$a_n$代表依赖图中与序号n的结点有关的属性：

__a4__:=real；
**a5**:=a4；
addtype(**id3**.entry,a5)；
**a7**:=a5；
addtype(**id2**.entry,a7)；
**a9**:=a7；
addtype(**id1**.entry,a9)；

输入符号串
         分析树
              依赖图
                    语义规则的计算顺序
                                    计算结果
## S - 属性定义的自底向上翻译
S属性定义：只用综合属性的语法制导定义

一、语法树
二、构造表达式的语法树
三、构造表达式的语法树的语法制导定义
四、表达式的有向非循环图（dag）
五、S属性定义的自底向上实现
### 语法树
把语法规则中对语义无关紧要的具体规定去掉，剩下来的本质性的东西称为抽象语法。

比如:
赋值语句：x=y、x:=y、或y$\to$x
抽象形式：assignment(variable,expression)


__语法树：__
分析树的抽象（或压缩）形式。
也称为语法结构树或结构树。
内部结点表示运算符号，其子结点表示它的运算分量。

![yufatree](/assets/yufatree.png)

### 构造表达式的语法树
为每一个运算符号或运算分量建立相应的结点，从而为子表达式建立子树。

`makenode(op,left,right)：`
建立一个运算符号结点，标号是 op
域 `left` 和 `right` 是指向其左右运算分量结点的指针。

`makeleaf(id,entry)：`
建立一个标识符结点，标号是id
域 `entry` 是指向该标识符在符号表中的相应条目的指针。

`makeleaf(num,val)：`
建立一个数结点，标号为 `num`,
 域 `val` 用于保存该数的值。

![a-4+c](/assets/a-4+c.png)

### 构造表达式的语法树的语法制导定义
|产生式|语义规则|
| --|--|
| $E \to E1+T$ | `E.nptr:=makenode(‘+’,E1.nptr,T.nptr)`
| $E\to E1-T$ |`E.nptr:=makenode(‘-’,E1.nptr,T.nptr)`
| $E\to T$ | `E.nptr:=T.nptr`
| $T\to (E)$ | `T.nptr:=E.nptr`
| $T\to id$ | `T.nptr:=makeleaf(id,id.entry)`
| $T\to num$ | `T.nptr:=makeleaf(num,num.val)`
为了记录在构造过程中建立的子树，为每个非终结符号引入一个综合属性 `nptr` 。
`nptr`是一个指针，指向语法树中相应非终结符号产生的表达式子树的根结点。
![mapping](/assets/mapping.png)

为表达式创建dag的函数makenode和makeleaf
+ 建立新结点之前先检查是否已经存在一个相同的结点
    + 若已存在，返回一个指向先前已构造好的结点的指针；
    + 否则，创建一个新结点，返回指向新结点的指针。


### 表达式的有向非循环图（dag）
这个东西的关键是复用。。。子结点有多个爹
dag与语法树相同的地方：
+ 表达式的每一个子表达式都有一个结点
+ 一个内部结点表示一个运算符号，且它的子结点表示它的运算分量。
dag与语法树不同的地方：
+ dag中，对应一个公共子表达式的结点具有多个父结点
语法树中，公共子表达式被表示为重复的子树
![eg_dag](/assets/eg_dag.png)
### S属性定义的自底向上实现
![1](/assets/cp/cp_2_LR.jpg)
1. 回忆在自底向上的分析方法中，分析器使用一个栈来存放已经分析过的子树的信息。
2. 分析树中某结点的综合属性由其子结点的属性值计算得到

所以 自底向上的分析器在分析输入符号串的同时可以计算综合属性

我们可以扩充分析栈使之能够保存综合属性
在分析栈中增加一个域val，来存放综合属性值

### 例：用LR分析器实现台式计算器
PPT4-35左右

## L属性
要么是左部是综合属性
要么右部是继承属性

每一个S属性定义都是L属性定义

### L属性的计算: 深度优先
在进入结点时计算它的继承属性
在返回结点时计算它的综合属性
```py
procedure  deepfirst(n:node);
begin
  for n的每一个子结点m，从左到右  do
  begin
    计算m的继承属性；
    deepfirst(m)
  end;
  计算n的综合属性
end
```

### 设计翻译方案
将生产式中插入合适的语义规则
比如
|||
|--|--|
| $S\to B$ | B.ps:=10 <br>S.ht:=B.ht|
S $\to$ {B.ps:=10} B {S.ht:=B.ht}


## L - 属性定义的自顶向下翻译
在自顶向下的分析过程中实现L属性定义的翻译
预测分析方法对文法的要求
+ 不含左递归
+ $A\to \alpha | \beta$
+ FIRST($\alpha$)$\cap$FIRST($\beta$)=∅

### 消除左递归
消除左递归的方法：
    $A\to A\alpha | \beta$
替换为：
    $A\to \beta R     $
    $R\to \alpha R | $ ε

### 例子
|  产生式     |  语义规则 |
|---|---|
| $ E\to E_1+T $ |  `E.val:=E1.val+T.val`
| $ E\to E_1-T $ |  `E.val:=E1.val-T.val`
| $ E\to T    $ |  `E.val:=T.val`
| $ T\to (E)  $ |  `T.val:=E.val`
| $ T\to num  $ |  `T.val:=num.val`
得到翻译方案
(1) $ E \to E1+T ${E.val:=E1.val+T.val}
(2) $ E \to E1-T ${E.val:=E1.val-T.val}
(3) $ E \to T    ${E.val:=T.val}
(4) $ T \to (E)  ${T.val:=E.val}
(5) $ T \to num  ${T.val:=num.val}
消除左递归
(1’)  $ E \to T${E.val:=T.val}$R$
(3’)  $ R \to +T ${E.val:=E1.val+T.val}$R_1$
(3’’) $ R \to $ ε

> 继承属性`R.i`：表示在R之前已经推导出的子表达式的值
> 综合属性`R.s`：表示在R完全展开之后得到的表达式的值

为__(3’’)__设置把`R.i`传递给`R.s`
得到：
__(3’’)  R→ε {R.s:=R.i}__

对于__(1’)__，通过`R`的属性`R.s`和`R.i`完成`E`和``T``的综合属性的传递`E.val:=T.val`，得到：
__(1’)  E → T {R.i:=T.val} R {E.val:=R.s}__

对于(3’) R→+T {E.val:=E1.val+T.val} R1
`R1.i`的语义规则为：`R1.i:=R.i+T.val`
`R.s`的语义规则为：`R.s:=R1.s`
于是得到：
__(3’)  R → +T {R1.i:=R.i+T.val} R1 {R.s:=R1.s}__

同样可得到：
(2’)  R→-T {R1.i:=R.i-T.val} R1 {R.s:=R1.s}

### 从上述方法们得到的翻译方案 得到 程序
有时间再倒过来记
为每个非终结符号构造一个函数
function E:↑syntax_tree_node；
function R(in:↑syntax_tree_node):↑syntax_tree_node；
function T:↑syntax_tree_node；

两个R产生式结合起来，用符号addop代表‘+’和‘-’
```
R→addop
       T  {R1.i:=makenode(addop.lexeme,R.i,T.nptr)}
      R1  {R.s:=R1.s}
R→ε {R.s:=R.i}
```

```
function R(in:↑syntax_tree_node):↑syntax_tree_node；
   var  tnptr,i1,s1,s:↑syntax_tree_node；
        addoplexeme:char；
   begin
      if lookahead=addop then
        begin  /* 产生式R→addopTR */
           addoplexeme:=lexval；
           match(addop)；
           tnptr:=T；
           i1:=makenode(addoplexeme,in,tnptr)；
           s1:=R(i1)；
           s:=s1
        end
      else  s:=in； /* 产生式R→ε */
      return s
   end；
```

## L - 属性定义的自底向上翻译
在自底向上的分析过程中实现L属性定义的翻译
可以实现任何基于LL(1)文法的L属性定义
可以实现许多（不是全部）基于LR(1)文法的L属性定义

一、从翻译方案中去掉嵌入的动作
二、分析栈中的继承属性
三、模拟继承属性的计算
四、用综合属性代替继承属性
### 一 从翻译方案中去掉嵌入的动作
+ 自底向上地处理继承属性
+ 等价变换：
    + 使所有嵌入的动作都出现在产生式的右端末尾
+ 方法：
    + 在基础文法中引入新的产生式，形如：__M → ε__
    + M：__标记非终结符号__，用来代替嵌入在产生式中的动作
    + 把被M替代的动作放在产生式 __M → ε__ 的末尾

eg.
去掉如下翻译方案中潜入的动作：
```
E→TR
R→+T {print(‘+’)} R |-T {print(‘-’)} R | ε
T→num {print(num.val)}
```
1.标记非终结符号M和N，及产生式 M → ε 和 N → ε
2.用M和N替换出现在R产生式中的动作

新的翻译方案
```
E → TR
R → +TMR | -TNR | ε
T →  num {print(num.val)}
M → ε {print(‘+’)}
N → ε {print(‘-’)}
```
变换前、后的翻译方案是等价的
### 二 分析栈中的继承属性
在栈中先读入 X→X1X2...Xn
再读入 Y→Y1Y2...Yk
会有Y.i:=X.s
![rewrite_rule](/assets/rewrite_rule.png)

### 三 模拟继承属性的计算

要想从栈中取得继承属性，当且仅当文法允许属性值在栈中存放的位置可以预测。
![exacc](/assets/exacc.png)
__用标记非终结符号模拟非复写规则的语义规则__
![exacceg](/assets/exacceg.png)

### 四 用综合属性代替继承属性
