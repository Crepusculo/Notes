
<!-- MDTOC maxdepth:6 firsth1:1 numbering:0 flatten:0 bullets:1 updateOnSave:1 -->

- [== [ 自顶向下分析方法 | Top-down parsing ] ==](#自顶向下分析方法-top-down-parsing)
   - [==!==递归下降分析](#递归下降分析)
      - [例子:试分析输入串 $\omega = cad$ 是否为如下文法的一个句子。](#例子试分析输入串-omega-cad-是否为如下文法的一个句子。)
      - [Q&A](#qa)
            - [为什么采用最左推导？](#为什么采用最左推导？)
            - [如何实现](#如何实现)
      - [总结](#总结)
   - [==!==不带回溯的递归下降分析器](#不带回溯的递归下降分析器)
      - [Q&A](#qa)
            - [如何克服回溯？](#如何克服回溯？)
            - [==!==对文法的要求 | 消除左递归](#对文法的要求-消除左递归)
            - [预测分析器的构造](#预测分析器的构造)
               - [==!==预测分析器的构造 - 预测分析器的转换图 | 从文法构造转换图](#预测分析器的构造-预测分析器的转换图-从文法构造转换图)
               - [预测分析器的构造 - 转换图的工作流程](#预测分析器的构造-转换图的工作流程)
               - [预测分析器的构造 - 转换图的化简](#预测分析器的构造-转换图的化简)
               - [预测分析器的构造 - 预测分析器的实现](#预测分析器的构造-预测分析器的实现)
   - [==!==非递归的预测分析器](#非递归的预测分析器)
      - [预测分析器的模型及工作过程-模型](#预测分析器的模型及工作过程-模型)
      - [预测分析器的模型及工作过程-工作过程](#预测分析器的模型及工作过程-工作过程)
      - [预测分析表的构造](#预测分析表的构造)
         - [==!== 求FIRST集和FOLLOW集](#求first集和follow集)
               - [FIRST 集求法](#first-集求法)
               - [FOLLOW 集的求法](#follow-集的求法)
               - [预测分析表的构造方法](#预测分析表的构造方法)
      - [==!== LL(1)文法](#ll1文法)
      - [预测分析方法中的错误处理示例](#预测分析方法中的错误处理示例)

<!-- /MDTOC -->

地位那些杂七杂八的东西我们就略过了

# == [ 自顶向下分析方法 | Top-down parsing ] ==
自顶向下方法是一种面向目标的分析方法。
分析时,**从文法的开始符号出发**, 进行**推导**, 试图推导出于要分析的输入符号串完全匹配的句子, (否则转入错误处理)。

## ==!==递归下降分析
- 从文法的**开始符号**出发, **向下推导**, 试图推出要分析的输入串的过程:
- 对给定的输入串, 从对应文法开始符号的根节点出发, 自顶向下地为输入串建立一棵分析树
- **试探过程, 是反复使用不同产生式谋求匹配输入串的过程。**
- **有回溯**, 试探失败时回溯

### 例子:试分析输入串 $\omega = cad$ 是否为如下文法的一个句子。

$ S \to cAd $
$ A \to ab | a $
![cp_1.jpg][1]

$ S \to cAd \to cad $
试图为输入符号串建立一个最左推导序列的过程。

### Q&A

##### 为什么采用最左推导？
> 因为对输入串的扫描是自左至右进行的，只有使用最左推导，才能保证按扫描的顺序匹配输入串。

##### 如何实现
> - 文法的每一个非终结符号对应一个递归过程，即可实现这种带回溯的递归下降分析方法。
> - 每个过程作为一个布尔过程，一旦发现它的某个产生式与输入串匹配，则用该产生式展开分析树，并返回true，否则分析树不变，返回false。

### 总结
实践中存在的困难和缺点
- 左递归的文法，可能导致分析过程陷入死循环。
- 成功是虚假的、暂时的，需要回溯
-  回溯需要将一些语义动作推倒重来
    - 各种表格的记录内容
    - 中间代码的产生
    - 费时麻烦
    - 有些动作无法回溯
- 是穷尽一切可能的试探法
    - 效率低
    - 代价高
    - 使用价值有限
    -
## ==!==不带回溯的递归下降分析器
- 无回溯
### Q&A
##### 如何克服回溯？
> 能够根据所面临的输入符号准确地指派一个候选式去执行任务。
该选择的工作结果是确信无疑的。
>
> 通过预读来确定唯一指定的右侧
>
> 例：
$A \to \alpha_1| \alpha 2|...|\alpha_n $
当前输入符号：a
指派$\alpha_i$去匹配输入符号串

##### ==!==对文法的要求 | 消除左递归
***PART. 1 对文法的要求***
> **一。不含左递归**
>
> **1. 直接左递归 (Immediate left recursion)**
> **$ A \to A\alpha \space|\space \beta$**
> 这里 $\alpha$  跟  $\beta$  代表不同的非终端符号跟终端符号组成的序列，并且 $\beta$  不一定要包含 $A$ 举例来说，以下规则
> $Expr \to Expr + Term $
就是一个直接左递归的例子。这规则的*递归下降分析器*可能会像这样:
> ```{c}
> fuction Expr()
> {
>   Expr(); match('+'); Term();
> }
> ```
> 然后这个递归下降分析器在尝试去解析包含此规则的文法时，会陷入一个无穷的递归。
>
> **2. 间接左递归 (Indirect left recursion)**
> 间接左递归 (indirect left recursion) 最简单的形式如下：
> **$ A \to B\alpha \space|\space C$**
> **$ B \to A\beta \space|\space D_1$**
> 这规则可能产生形如 $ A \to B\alpha \to A\beta\alpha \to ...$ 这样的生成
> 简单的说，间接左递归就是，并非在一条规则内完成左递归，而是在许多条规则之后，于产生的句子最左边出现了一开始的非终端符号。
更一般化的说法，对非终端符号 $ A_0, A_1, \ldots, A_n$，间接左递归被定义为以下的型态：
> **$ A_0 \to A_1\alpha_1 \mid \ldots $
$ A_1 \to A_2\alpha_2 \mid \ldots $
$ \cdots $
$ A_n \to A_0\alpha_{n+1} \mid \ldots  $**
> 这里的 $ \alpha_1, \alpha_2, \ldots, \alpha_n $都是一堆终端与非终端符号的序列。


> **二。$ FIRST (\alpha_i) \cap FIRST(\alpha_j)= \phi \,\,\,\,\,(i \ne j)$**
>



***PART. 2 消除左递归***
一个一般化后移除直接左递归的算法如下所述。 这个方法已经有过许多的改进，包括 Robert C. Moore 所撰写，名为 "Removing Left Recursion from Context-Free Grammars" 的改进。
对于每个规则如下
**$  A \to A\alpha_1\,|\,\ldots\,|\,A\alpha_n\,|\,\beta_1\,|\,\ldots\,|\,\beta_m $**
(注意这里：
- **A** 是一个有左递归的非终端符号
- **$ \alpha $** 是一个终端与非终端符号的序列，而且不为空字串 ( $  \alpha \ne \epsilon $)
- **$ \beta$**  是一个不以 **A** 开头的，以终端与非终端符号组成的序列)

将 A 的规则改成以下规则：
**$ A \rightarrow \beta_1A^\prime\, |\, \ldots\,  |\,  \beta_mA^\prime $**
然后对新创造出来非终端符号的规则
**$ A^\prime \rightarrow \epsilon\, |\, \alpha_1A^\prime\,  |\,  \ldots\, |\, \alpha_nA^\prime
$**
这个新创造出来的符号常被称为 "尾巴"(tail)，或者 "rest"(剩余)

举例，考虑以下规则
**$ Expr \rightarrow Expr\,+\,Expr\,|\,Int\,|\,String $**
我们可以改写为
**$ Expr \rightarrow Int\,ExprRest\,|\,String\,ExprRest
$**
**$ExprRest \rightarrow \epsilon\,|\,+\,Expr\,ExprRest $**
然后最后一个规则可以缩短改写为
**$ExprRest \rightarrow \epsilon\,|\,+\,Expr$**
来避免掉左递归的出现
***PART. 3 消除间接左递归***
如果文法内不存在 $ \epsilon $(代表空字串) 的生成 (不存在 $ A \rightarrow \ldots | \epsilon | \ldots $ 这样的规则)，而且不是循环 (cyclic) 的文法 (对所有非终端符号 A，不存在像是 $ A \Rightarrow  \ldots \Rightarrow A $ 这种形式的规则)，以下这个一般化的算法可以用来去除文法的间接左递归：
将所有非终端符号以某个固定的顺序 $ A_1, \ldots A_n $ 排列



- 从 i = 1 到 n {
    - 从 j = 1 到 i – 1 {
        - 设 $A_{j}$ 的生成规则为
$ A_j \rightarrow \delta_1 | \ldots | \delta_k$
        - 将所有规则 $ A_i \rightarrow A_j \gamma $ 换成
$ A_i \rightarrow \delta_1\gamma | \ldots | \delta_k\gamma$
移除 $ A_{i}$ 规则中的直接左递归
    - }
- }

----------

##### 预测分析器的构造
###### ==!==预测分析器的构造 - 预测分析器的转换图 | 从文法构造转换图
- 为预测分析器建立转换图作为其实现蓝图
- 每一个非终结符号有一张图
- 有向边的标记可以是终结符号，也可以是非终结符号。
- 在一个非终结符号A上的转移意味着对相应A的过程的调用。
- 在一个终结符号a上的转移，意味着下一个输入符号若为a，则应做此转移。

1. 消除左递归
2. 为每个非终结符号构造转换图

例:为如下文法构造预测分析器转换图
```
E → E+T | T
T → T*F | F
F → (E) | id
```
1. 消除左递归, 得到

```
E → TE’
E’ → +TE’ | ε
T → FT’
T’→*FT’ | ε
F → (E) | id
```

2. 为每个非终结符号构造转换图:
![Recource\cp_2][2]


###### 预测分析器的构造 - 转换图的工作流程
- 从文法开始符号所对应的转换图的开始状态开始分析
- 三种情况: 终结符号, 非终结符号, 空

![Recource\cp_3][3]

###### 预测分析器的构造 - 转换图的化简
用代入的方法进行化简
```
E’ → +TE’ | ε
```

![Recource\cp_4][4]

```
E → TE’
E’ → +TE’ | ε
T → FT’
T’→*FT’ | ε
F → (E) | id
```
把E’的转换图代入E的转换图, 一开始的 图[Recource\cp_1](..\assets\cp\cp_1)就能再次化简

![Recource\cp_5][5]

###### 预测分析器的构造 - 预测分析器的实现
- 要求: 允许递归
**E:**
![Recource\cp_5_E](..\assets\cp\cp_5_E.jpg)

```c
void procE(void)
{
   procT();
   if(char=='+'){
      forward pointer;
      procE();
    }
 }
```
**T:**
![Recource\cp_5_T](..\assets\cp\cp_5_T.jpg)

```c
void procT(void)
{
    procF();
    if (char=='*'){
         forward pointer;
         procT();
    }
}

```
**F:**
![Recource\cp_5_F](..\assets\cp\cp_5_F.jpg)

```c
void procF(void);
{
    if (char=='(') {
        forward pointer;y
        procE();
        if (char==')')
            forward pointer;
        else error()
        }
    else if (char=='id')
             forward pointer;
        else error();
}

```

## ==!==非递归的预测分析器
使用一张分析表和一个栈联合控制，实现对输入符号串的自顶向下分析

- **预测分析器的模型及工作过程**
- **预测分析表的构造**
- **LL(1)文法**
- **预测分析方法中的错误处理示例**

### 预测分析器的模型及工作过程-模型
![Resource\cp_6.jpg][6]
核心：预测分析控制程序
表驱动的预测分析器

**输入缓冲器**:
- 存放被分析的输入符号串，串后随右尾标志符 `$`。

**符号栈**:
- 存放一系列文法符号，\$存于栈底。分析开始时，先将\$入栈，以标识栈底，然后再将文法的开始符号入栈。

**分析表**:
- 二维数组**$M[A,\,a]$，$ A \in V_N$，$ a \in V_T \cup{\$} $**。
- **$V_N$** 是非终结符的集合
- **$V_T$** 是终结符的集合
- 根据给定的 **A** 和 **a**，在分析表 **M** 中找到将被调用的产生式。


**输出流**:
- 分析过程中不断产生的产生式序列。

**预测分析控制程序**:
根据 **X**(符号栈) 和 **a**(当前输入缓存器读入的值)，决定分析器的动作。
有4种可能：
1. **$X=a=\$$**，则分析器宣告分析成功，停止分析
2. **$X=a \ne \$ $**，则分析器从栈顶弹出X，输入指针前移一个位置。
3. **$X \in V_T$**(终结符)，但**$X\ne a$**，则分析器报告发现错误，调用错误处理程序，以报告错误及进行错误恢复。
4. 若 **$X$** 是非终结符号，则分析器访问分析表 **M[X,a]**

**$M[X,a]=X \to Y1Y2...Yn$**
则先将X从栈顶弹出，然后把产生式的右部符号串按反序（即按**Yn、...、Yn-1、Y2、Y1**的顺序）一一推入栈中；
**$M[X,a]=X \to \epsilon$**
则分析器从栈顶弹出**$X$**；
**$M[X,a]=error$**
则分析器调用出错处理程序。

### 预测分析器的模型及工作过程-工作过程
**开始状态**

符号栈:
|S|
|--|
|**$**|

输入缓存器:
|a|...|...|...|**$**|
|--|--|--|--|--|
输入缓存流指针指向 **a**

**成功状态**

符号栈:
|**$**|
|--|

输入缓存器:
|a|...|...|...|**$**|
|--|--|--|--|--|
输入缓存流指针指向 **$**


**非递归的预测分析方法**
输入：输入符号串ω，文法G的一张预测分析表M。
输出：若ω在L(G)中，则输出ω的最左推导，否则报告错误。
方法：分析开始时，\$在栈底，文法开始符号S在栈顶，ω\\$在输入缓冲器中。
```python
  置ip指向 ω$ 的第一个符号；
    do{
        令X是栈顶符号，a是ip所指向的符号；
        if X是终结符号或$:
            if (X = a):
                从栈顶弹出X; ip前移一个位置
            else:
                error()
        else  /* X是非终结符号 */
            if M[X,a] = X → Y1Y2…Yk:
                从栈顶弹出X
                把Yk、Yk-1、…Y2、Y1压入栈，Y1在栈顶
                输出产生式X → Y1Y2…Yk
            else
                error()
  } While( X != $ )  /* 栈非空，继续分析 */
```

直到 `X = a = 一个非终结符`之前疯狂替换,
直到 `X = a = 终结符` 时弹出栈顶进行下一步

例:
通过预测分析表 M, 试分析输入串`id+id*id`
|   | id | + | * | ( | ) | $ |
|:-|--|--|--|--|--|--|
| E | E → TE' |  |  | E  → TE'  |  |  |
| E'|  | E' → +TE' |  |  | E' → ε | E' → ε |
| T | T → FT' |  |  | T  → FT' |  |  |
| T'|  | T' → ε | T' → *FT' |  | T' → ε | T' → ε |
| F | F → id  |  |  | F  → (E) |  |  |

| 栈      | 输入 | 输出 | 左句型 |
| :-      | --: | :--:| :-----|
| $E      | `id+id*id$`  |           | E
| $E'T    | `id+id*id$`  |  E → TE' | TE'
| $E'T'F  | `id+id*id$`  |  T → FT' | FT'E'
| $E'T'id | `id+id*id$`  |  F → id  | idT'E'
| $E'T'   | `+id*id$`    |           | idT'E'
| $E'     | `+id*id$`    |   T' → ε | idE'
| $E'T+   |  `+id*id$`   | E' → +TE'| id+TE'
| $E'T    |  `id*id$`    |           | id+TE'
| $E'T'F  | `id*id$`     |  T → FT' | id+FT'E'
| $E'T'id | `id*id$`     | F → id   | id+idT'E'
| $E'T'   | `*id$`       |           |  id+idT'E'
| $E'T'F* | `*id$`       | T' → *FT'| id+id*FT'E'
| $E'T'F  | `id$`        |           | id+id*FT'E'
| $E'T'id | `id$`        |  F → id  | id+id*idT'E'
| $E'T'    | `$`         |            |  id+id*idT'E'
| $E'      | `$`         |  T' → ε   |  id+id*idE'
| $        |   `$`       |  E' → ε   |  id+id*id

### 预测分析表的构造
#### ==!== 求FIRST集和FOLLOW集

###### FIRST 集求法
First 集合最终是对产生式右部的字符串而言的，但其关键是求出非终结符的 First 集合，由于终结符的 First 集合就是它自己，所以求出非终结符的 First 集合后，就可很直观地得到每个字符串的 First 集合。
1. 直接收取：对形如 A→a… 的产生式（其中 a 是终结符），把 a 收入到 First(U) 中
2. 反复传送：对形入 A→B… 的产生式（其中 B 是非终结符），应把 First(B) 中的全部内容传送到 First(A) 中。

###### FOLLOW 集的求法

如果产生式中包含ε，则求出 follow, 否则是不需要求 follow 集的。

Follow 集合是针对非终结符而言的，Follow(U) 所表达的是句型中非终结符 U 所有可能的后随终结符号的集合，特别地，“#” 是识别符号的后随符。注意 Follow 集合是从开始符号 S 开始推导。

1. 直接收取：注意产生式右部的每一个形如 “…Ua…” 的组合，把 a 直接收入到 Follow(U) 中。因 a 是紧跟在 U 后的终结符。

2. 直接收取：对形如 “…UP…”(P 是非终结符) 的组合，把  First( P ) 直接收入到 Follow(U) 中【在这里，如果 First( P )中有空字符，那么就要把左部（假设是 S）的 Follow（S）送入到 Follow（U）中。还有就是 Follow 集中是没有空字符的】。
3. 直接收取：若 S－>…U，即以 U 结尾，则 #∈Follow(U)
4. *反复传送：对形如 U－>…P 的产生式（其中 P 是非终结符），应把 Follow(U) 中的全部内容传送到 Follow( P ) 中。

**Follow集2(李文生PPT)**
- 对文法开始符号**$S$**，置**\$**于FOLLOW(S)中，**\$**为输入符号串的右尾标志。
- 若**$ A\to \alpha B \beta $**是产生式，则把 **$FIRST(\beta)$** 中的所有非 **ε** 元素加入到**$FOLLOW(B)$**中。
- 若**$A\to\alpha B$**是产生式，或**$ A\to \alpha B \beta $**是产生式并且**$\beta {\Rightarrow}^{\star} $** **ε**，则把**FOLLOW(A)**中的所有元素加入到**FOLLOW(B)**中。


> **例 1：判断该文法是不是 LL(1) 文法，说明理由 S→ABc A→a|ε B→b|ε？**
    First 集合求法就是：能由非终结符号推出的所有的开头符号或可能的ε，但要求这个开头符号是终结符号。如此题 A 可以推导出 a 和ε，所以 FIRST（A）=｛a，ε｝；同理 FIRST（B）={b,ε};S 可以推导出 aBc，还可以推导出 bc，还可以推导出 c，所以 FIRST(S）=｛a，b，c｝。
    Follow 集合的求法是：紧跟随其后面的终结符号或＃。但文法的识别符号包含＃，在求的时候还要考虑到ε。具体做法是把所有包含你要求的符号的产生式都找出来，再看哪个有用。 Follow（S）=｛＃｝ 如求 A 的，产生式：S→ABc A→a|ε ，但只有 S→ABc 有用。跟随在 A 后面的终结符号是 FIRST（B）=｛b，ε｝，当 FIRST（B）的元素为ε时，跟随在 A 后的符号就是 c，所以 Follow（A）=｛b，c｝ 同理 Follow（B）=｛c｝。

> **例 2: 构造文法4.4中每个非终结符号的FIRST和FOLLOW函数**。
>```
>E  →  TE’
>E’ →  +TE’ | ε
>T  →  FT’
>T’ →  *FT’ | ε
>F  →  (E)  | id
>```
> ```
> FIRST(E) = FIRST(T') = FIRST(F) = { ( , id }
> FIRST(E') = {+, ε}
> FIRST(T') = {*, ε}
>
> FOLLOW(E) = FOLLOW(E') = { ),$ }
> FOLLOW(T) = FOLLOW(T') = { +,),$}
> FOLLOW(F) = { *,+,),$ }
> ```

求出 FIRST 集和 FOLLOW 集以后, 我们就能够通过这两者来求出预测分析表 M 了

###### 预测分析表的构造方法

输入：文法G
输出：文法G的预测分析表M
方法：
```{python}
    for 文法G的每个产生式 A→α :
        for 每个终结符号 a in FIRST(α) :
            把 A→α 放入 M[A,a] 中
        if ε in FIRST(α):
            for 任何b in FOLLOW(A):
                把 A→α 放入M[A,b]中
    for 所有无定义的 M[A,a]:
        标上错误标志.
```

对产生式 `E→TE’`：
由于`FIRST(TE’)=FIRST(T)={ (,id }`,
故应把`E→TE’`放入`M[E,( ]`和`M[E,id]`中。

对于产生式`E’→+TE’`：
由于`FIRST(+TE’)={ + }`,
所以，应把`E’→+TE`放入`M[E’,+]`中。

对于产生式`E’→ε`：
由于`FOLLOW(E’)={ ),$ }`,
故应把`E’→ε`放入`M[E’,)]`和`M[E’,$]`中。

### ==!== LL(1)文法
LL(1)的含义：
- 第一个L表示**从左至右扫描输入符号串**
- 第二个L表示生成输入串的一个**最左推导**
- **1** 表示在决定分析器的每步动作时，向前看一个符号。


如果一个文法的预测分析表M不含多重定义的表项，则称该文法为LL(1)文法

- 一个文法是LL(1)文法，当且仅当它的每一个产生式**$A\to\alpha|\beta$**，满足：
    - FIRST($\alpha$)∩FIRST($\beta$) = $\Phi$
    - 若$\beta$推导出$\epsilon$，则FIRST($\alpha$)∩FOLLOW(A)= $\Phi$

- 构造出的分析表中不含多重定义的表项
- 不含左递归
- 所以下面这个文法不是LL(1)文法
    - 因为FIRST(es)∩FOLLOW(S’)={e}
    - M[S’,e]中两个产生式



> **例: 考虑如下映射程序设计语言中if语句的文法**
> ```
> S  → iEtSS’|a
> S’ → eS | ε
> E  → b
> ```
>
> 1. 得出FIRST集和FOL
>
> |     |  S | S' | E |
> | ----| --| ---|  --|
> |FIRST |i,a|e,ε|b
> |FOLLOW|e,\$|e,\$|t
>
> 2. 求出预测分析表 M
>
> |      |  a | b | e | i | t | $ |
> | ---- | -- | ---|  --| --| --|--|
> |**S** | S→a | ||S→iEtSS'|||
> |**S'**|||S'→eS</br>S'→ε|||S'→ε|
> |**E** ||E→b|||||

### 预测分析方法中的错误处理示例

-----------------------


[1]:..\assets\cp\cp_1.jpg
[2]:..\assets\cp\cp_2.jpg
[3]:..\assets\cp\cp_3.jpg
[4]:..\assets\cp\cp_4.jpg
[5]:..\assets\cp\cp_5.jpg
[6]:..\assets\cp\cp_6.jpg
